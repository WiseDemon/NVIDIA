/*
 * Copyright (c) 2008-2015, NVIDIA CORPORATION.  All rights reserved.
 *
 * NVIDIA CORPORATION and its licensors retain all intellectual property
 * and proprietary rights in and to this software, related documentation
 * and any modifications thereto.  Any use, reproduction, disclosure or
 * distribution of this software and related documentation without an express
 * license agreement from NVIDIA CORPORATION is strictly prohibited.
 */


// This file was generated by NxParameterized/scripts/GenParameterized.pl
// Created: 2015.01.18 19:26:28

#include "TurbulenceFSAssetParams_1p4.h"
#include <string.h>
#include <stdlib.h>

using namespace NxParameterized;

namespace physx
{
namespace apex
{

using namespace TurbulenceFSAssetParams_1p4NS;

const char* const TurbulenceFSAssetParams_1p4Factory::vptr =
    NxParameterized::getVptr<TurbulenceFSAssetParams_1p4, TurbulenceFSAssetParams_1p4::ClassAlignment>();

const physx::PxU32 NumParamDefs = 77;
static NxParameterized::DefinitionImpl* ParamDefTable; // now allocated in buildTree [NumParamDefs];


static const size_t ParamLookupChildrenTable[] =
{
	1, 4, 7, 10, 11, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29,
	30, 31, 32, 33, 34, 35, 40, 41, 45, 46, 47, 53, 58, 59, 60, 61, 62, 76, 2, 3, 5,
	6, 8, 9, 12, 13, 36, 37, 38, 39, 42, 43, 44, 48, 49, 50, 51, 52, 54, 55, 56, 57,
	63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75,
};

#define TENUM(type) physx::##type
#define CHILDREN(index) &ParamLookupChildrenTable[index]
static const NxParameterized::ParamLookupNode ParamLookupTable[NumParamDefs] =
{
	{ TYPE_STRUCT, false, 0, CHILDREN(0), 39 },
	{ TYPE_STRUCT, false, (size_t)(&((ParametersStruct*)0)->gridXRange), CHILDREN(39), 2 }, // gridXRange
	{ TYPE_ENUM, false, (size_t)(&((turbulenceRangeStructEnum_Type*)0)->min), NULL, 0 }, // gridXRange.min
	{ TYPE_ENUM, false, (size_t)(&((turbulenceRangeStructEnum_Type*)0)->max), NULL, 0 }, // gridXRange.max
	{ TYPE_STRUCT, false, (size_t)(&((ParametersStruct*)0)->gridYRange), CHILDREN(41), 2 }, // gridYRange
	{ TYPE_ENUM, false, (size_t)(&((turbulenceRangeStructEnum_Type*)0)->min), NULL, 0 }, // gridYRange.min
	{ TYPE_ENUM, false, (size_t)(&((turbulenceRangeStructEnum_Type*)0)->max), NULL, 0 }, // gridYRange.max
	{ TYPE_STRUCT, false, (size_t)(&((ParametersStruct*)0)->gridZRange), CHILDREN(43), 2 }, // gridZRange
	{ TYPE_ENUM, false, (size_t)(&((turbulenceRangeStructEnum_Type*)0)->min), NULL, 0 }, // gridZRange.min
	{ TYPE_ENUM, false, (size_t)(&((turbulenceRangeStructEnum_Type*)0)->max), NULL, 0 }, // gridZRange.max
	{ TYPE_VEC3, false, (size_t)(&((ParametersStruct*)0)->gridSizeWorld), NULL, 0 }, // gridSizeWorld
	{ TYPE_STRUCT, false, (size_t)(&((ParametersStruct*)0)->updatesPerFrameRange), CHILDREN(45), 2 }, // updatesPerFrameRange
	{ TYPE_F32, false, (size_t)(&((rangeStructF32_Type*)0)->min), NULL, 0 }, // updatesPerFrameRange.min
	{ TYPE_F32, false, (size_t)(&((rangeStructF32_Type*)0)->max), NULL, 0 }, // updatesPerFrameRange.max
	{ TYPE_F32, false, (size_t)(&((ParametersStruct*)0)->angularVelocityMultiplier), NULL, 0 }, // angularVelocityMultiplier
	{ TYPE_F32, false, (size_t)(&((ParametersStruct*)0)->angularVelocityClamp), NULL, 0 }, // angularVelocityClamp
	{ TYPE_F32, false, (size_t)(&((ParametersStruct*)0)->linearVelocityMultiplier), NULL, 0 }, // linearVelocityMultiplier
	{ TYPE_F32, false, (size_t)(&((ParametersStruct*)0)->linearVelocityClamp), NULL, 0 }, // linearVelocityClamp
	{ TYPE_F32, false, (size_t)(&((ParametersStruct*)0)->velocityFieldFadeTime), NULL, 0 }, // velocityFieldFadeTime
	{ TYPE_F32, false, (size_t)(&((ParametersStruct*)0)->velocityFieldFadeDelay), NULL, 0 }, // velocityFieldFadeDelay
	{ TYPE_F32, false, (size_t)(&((ParametersStruct*)0)->velocityFieldFadeIntensity), NULL, 0 }, // velocityFieldFadeIntensity
	{ TYPE_F32, false, (size_t)(&((ParametersStruct*)0)->boundaryFadePercentage), NULL, 0 }, // boundaryFadePercentage
	{ TYPE_F32, false, (size_t)(&((ParametersStruct*)0)->boundarySizePercentage), NULL, 0 }, // boundarySizePercentage
	{ TYPE_STRING, false, (size_t)(&((ParametersStruct*)0)->collisionFilterDataName), NULL, 0 }, // collisionFilterDataName
	{ TYPE_STRING, false, (size_t)(&((ParametersStruct*)0)->fieldBoundaryFilterDataName), NULL, 0 }, // fieldBoundaryFilterDataName
	{ TYPE_STRING, false, (size_t)(&((ParametersStruct*)0)->fieldSamplerFilterDataName), NULL, 0 }, // fieldSamplerFilterDataName
	{ TYPE_U32, false, (size_t)(&((ParametersStruct*)0)->maxCollidingObjects), NULL, 0 }, // maxCollidingObjects
	{ TYPE_U32, false, (size_t)(&((ParametersStruct*)0)->maxVelocitySources), NULL, 0 }, // maxVelocitySources
	{ TYPE_U32, false, (size_t)(&((ParametersStruct*)0)->maxHeatSources), NULL, 0 }, // maxHeatSources
	{ TYPE_U32, false, (size_t)(&((ParametersStruct*)0)->maxSubstanceSources), NULL, 0 }, // maxSubstanceSources
	{ TYPE_F32, false, (size_t)(&((ParametersStruct*)0)->dragCoeff), NULL, 0 }, // dragCoeff
	{ TYPE_VEC3, false, (size_t)(&((ParametersStruct*)0)->externalVelocity), NULL, 0 }, // externalVelocity
	{ TYPE_F32, false, (size_t)(&((ParametersStruct*)0)->fieldVelocityMultiplier), NULL, 0 }, // fieldVelocityMultiplier
	{ TYPE_F32, false, (size_t)(&((ParametersStruct*)0)->fieldVelocityWeight), NULL, 0 }, // fieldVelocityWeight
	{ TYPE_BOOL, false, (size_t)(&((ParametersStruct*)0)->useHeat), NULL, 0 }, // useHeat
	{ TYPE_STRUCT, false, (size_t)(&((ParametersStruct*)0)->heatParams), CHILDREN(47), 4 }, // heatParams
	{ TYPE_F32, false, (size_t)(&((HeatParams_Type*)0)->temperatureBasedForceMultiplier), NULL, 0 }, // heatParams.temperatureBasedForceMultiplier
	{ TYPE_F32, false, (size_t)(&((HeatParams_Type*)0)->ambientTemperature), NULL, 0 }, // heatParams.ambientTemperature
	{ TYPE_VEC3, false, (size_t)(&((HeatParams_Type*)0)->heatForceDirection), NULL, 0 }, // heatParams.heatForceDirection
	{ TYPE_F32, false, (size_t)(&((HeatParams_Type*)0)->thermalConductivity), NULL, 0 }, // heatParams.thermalConductivity
	{ TYPE_BOOL, false, (size_t)(&((ParametersStruct*)0)->useDensity), NULL, 0 }, // useDensity
	{ TYPE_STRUCT, false, (size_t)(&((ParametersStruct*)0)->densityParams), CHILDREN(51), 3 }, // densityParams
	{ TYPE_F32, false, (size_t)(&((DensityParams_Type*)0)->diffusionCoef), NULL, 0 }, // densityParams.diffusionCoef
	{ TYPE_F32, false, (size_t)(&((DensityParams_Type*)0)->densityFieldFade), NULL, 0 }, // densityParams.densityFieldFade
	{ TYPE_U32, false, (size_t)(&((DensityParams_Type*)0)->densityGridMultiplier), NULL, 0 }, // densityParams.densityGridMultiplier
	{ TYPE_BOOL, false, (size_t)(&((ParametersStruct*)0)->isEnabledOptimizedLOD), NULL, 0 }, // isEnabledOptimizedLOD
	{ TYPE_F32, false, (size_t)(&((ParametersStruct*)0)->customLOD), NULL, 0 }, // customLOD
	{ TYPE_STRUCT, false, (size_t)(&((ParametersStruct*)0)->lodWeights), CHILDREN(54), 5 }, // lodWeights
	{ TYPE_F32, false, (size_t)(&((LODWeights_Type*)0)->maxDistance), NULL, 0 }, // lodWeights.maxDistance
	{ TYPE_F32, false, (size_t)(&((LODWeights_Type*)0)->distanceWeight), NULL, 0 }, // lodWeights.distanceWeight
	{ TYPE_F32, false, (size_t)(&((LODWeights_Type*)0)->bias), NULL, 0 }, // lodWeights.bias
	{ TYPE_F32, false, (size_t)(&((LODWeights_Type*)0)->benefitBias), NULL, 0 }, // lodWeights.benefitBias
	{ TYPE_F32, false, (size_t)(&((LODWeights_Type*)0)->benefitWeight), NULL, 0 }, // lodWeights.benefitWeight
	{ TYPE_STRUCT, false, (size_t)(&((ParametersStruct*)0)->noiseParams), CHILDREN(59), 4 }, // noiseParams
	{ TYPE_F32, false, (size_t)(&((NoiseParams_Type*)0)->noiseStrength), NULL, 0 }, // noiseParams.noiseStrength
	{ TYPE_VEC3, false, (size_t)(&((NoiseParams_Type*)0)->noiseSpacePeriod), NULL, 0 }, // noiseParams.noiseSpacePeriod
	{ TYPE_F32, false, (size_t)(&((NoiseParams_Type*)0)->noiseTimePeriod), NULL, 0 }, // noiseParams.noiseTimePeriod
	{ TYPE_U32, false, (size_t)(&((NoiseParams_Type*)0)->noiseOctaves), NULL, 0 }, // noiseParams.noiseOctaves
	{ TYPE_F32, false, (size_t)(&((ParametersStruct*)0)->dragCoeffForRigidBody), NULL, 0 }, // dragCoeffForRigidBody
	{ TYPE_F32, false, (size_t)(&((ParametersStruct*)0)->fluidViscosity), NULL, 0 }, // fluidViscosity
	{ TYPE_REF, false, (size_t)(&((ParametersStruct*)0)->volumeRenderMaterialName), NULL, 0 }, // volumeRenderMaterialName
	{ TYPE_BOOL, false, (size_t)(&((ParametersStruct*)0)->useFlame), NULL, 0 }, // useFlame
	{ TYPE_STRUCT, false, (size_t)(&((ParametersStruct*)0)->flameParams), CHILDREN(63), 13 }, // flameParams
	{ TYPE_F32, false, (size_t)(&((FlameParams_Type*)0)->IgnitionTemp), NULL, 0 }, // flameParams.IgnitionTemp
	{ TYPE_F32, false, (size_t)(&((FlameParams_Type*)0)->MaxIgnitionTemp), NULL, 0 }, // flameParams.MaxIgnitionTemp
	{ TYPE_F32, false, (size_t)(&((FlameParams_Type*)0)->ReactionSpeed), NULL, 0 }, // flameParams.ReactionSpeed
	{ TYPE_F32, false, (size_t)(&((FlameParams_Type*)0)->HeatReleased), NULL, 0 }, // flameParams.HeatReleased
	{ TYPE_F32, false, (size_t)(&((FlameParams_Type*)0)->DensityEmission), NULL, 0 }, // flameParams.DensityEmission
	{ TYPE_F32, false, (size_t)(&((FlameParams_Type*)0)->FuelInefficiency), NULL, 0 }, // flameParams.FuelInefficiency
	{ TYPE_F32, false, (size_t)(&((FlameParams_Type*)0)->Expansion), NULL, 0 }, // flameParams.Expansion
	{ TYPE_F32, false, (size_t)(&((FlameParams_Type*)0)->Cooling), NULL, 0 }, // flameParams.Cooling
	{ TYPE_F32, false, (size_t)(&((FlameParams_Type*)0)->Buoyancy), NULL, 0 }, // flameParams.Buoyancy
	{ TYPE_VEC3, false, (size_t)(&((FlameParams_Type*)0)->BuoyancyUpVector), NULL, 0 }, // flameParams.BuoyancyUpVector
	{ TYPE_F32, false, (size_t)(&((FlameParams_Type*)0)->RoomTemperature), NULL, 0 }, // flameParams.RoomTemperature
	{ TYPE_VEC4, false, (size_t)(&((FlameParams_Type*)0)->Dissipation), NULL, 0 }, // flameParams.Dissipation
	{ TYPE_U32, false, (size_t)(&((FlameParams_Type*)0)->ResolutionMultiplier), NULL, 0 }, // flameParams.ResolutionMultiplier
	{ TYPE_ENUM, false, (size_t)(&((ParametersStruct*)0)->solverAccuracy), NULL, 0 }, // solverAccuracy
};


bool TurbulenceFSAssetParams_1p4::mBuiltFlag = false;
NxParameterized::MutexType TurbulenceFSAssetParams_1p4::mBuiltFlagMutex;

TurbulenceFSAssetParams_1p4::TurbulenceFSAssetParams_1p4(NxParameterized::Traits* traits, void* buf, PxI32* refCount) :
	NxParameters(traits, buf, refCount)
{
	//mParameterizedTraits->registerFactory(className(), &TurbulenceFSAssetParams_1p4FactoryInst);

	if (!buf) //Do not init data if it is inplace-deserialized
	{
		initDynamicArrays();
		initStrings();
		initReferences();
		initDefaults();
	}
}

TurbulenceFSAssetParams_1p4::~TurbulenceFSAssetParams_1p4()
{
	freeStrings();
	freeReferences();
	freeDynamicArrays();
}

void TurbulenceFSAssetParams_1p4::destroy()
{
	// We cache these fields here to avoid overwrite in destructor
	bool doDeallocateSelf = mDoDeallocateSelf;
	NxParameterized::Traits* traits = mParameterizedTraits;
	physx::PxI32* refCount = mRefCount;
	void* buf = mBuffer;

	this->~TurbulenceFSAssetParams_1p4();

	NxParameters::destroy(this, traits, doDeallocateSelf, refCount, buf);
}

const NxParameterized::DefinitionImpl* TurbulenceFSAssetParams_1p4::getParameterDefinitionTree(void)
{
	if (!mBuiltFlag) // Double-checked lock
	{
		NxParameterized::MutexType::ScopedLock lock(mBuiltFlagMutex);
		if (!mBuiltFlag)
		{
			buildTree();
		}
	}

	return(&ParamDefTable[0]);
}

const NxParameterized::DefinitionImpl* TurbulenceFSAssetParams_1p4::getParameterDefinitionTree(void) const
{
	TurbulenceFSAssetParams_1p4* tmpParam = const_cast<TurbulenceFSAssetParams_1p4*>(this);

	if (!mBuiltFlag) // Double-checked lock
	{
		NxParameterized::MutexType::ScopedLock lock(mBuiltFlagMutex);
		if (!mBuiltFlag)
		{
			tmpParam->buildTree();
		}
	}

	return(&ParamDefTable[0]);
}

NxParameterized::ErrorType TurbulenceFSAssetParams_1p4::getParameterHandle(const char* long_name, Handle& handle) const
{
	ErrorType Ret = NxParameters::getParameterHandle(long_name, handle);
	if (Ret != ERROR_NONE)
	{
		return(Ret);
	}

	size_t offset;
	void* ptr;

	getVarPtr(handle, ptr, offset);

	if (ptr == NULL)
	{
		return(ERROR_INDEX_OUT_OF_RANGE);
	}

	return(ERROR_NONE);
}

NxParameterized::ErrorType TurbulenceFSAssetParams_1p4::getParameterHandle(const char* long_name, Handle& handle)
{
	ErrorType Ret = NxParameters::getParameterHandle(long_name, handle);
	if (Ret != ERROR_NONE)
	{
		return(Ret);
	}

	size_t offset;
	void* ptr;

	getVarPtr(handle, ptr, offset);

	if (ptr == NULL)
	{
		return(ERROR_INDEX_OUT_OF_RANGE);
	}

	return(ERROR_NONE);
}

void TurbulenceFSAssetParams_1p4::getVarPtr(const Handle& handle, void*& ptr, size_t& offset) const
{
	ptr = getVarPtrHelper(&ParamLookupTable[0], const_cast<TurbulenceFSAssetParams_1p4::ParametersStruct*>(&parameters()), handle, offset);
}


/* Dynamic Handle Indices */

void TurbulenceFSAssetParams_1p4::freeParameterDefinitionTable(NxParameterized::Traits* traits)
{
	if (!traits)
	{
		return;
	}

	if (!mBuiltFlag) // Double-checked lock
	{
		return;
	}

	NxParameterized::MutexType::ScopedLock lock(mBuiltFlagMutex);

	if (!mBuiltFlag)
	{
		return;
	}

	for (physx::PxU32 i = 0; i < NumParamDefs; ++i)
	{
		ParamDefTable[i].~DefinitionImpl();
	}

	traits->free(ParamDefTable);

	mBuiltFlag = false;
}

#define PDEF_PTR(index) (&ParamDefTable[index])

void TurbulenceFSAssetParams_1p4::buildTree(void)
{

	physx::PxU32 allocSize = sizeof(NxParameterized::DefinitionImpl) * NumParamDefs;
	ParamDefTable = (NxParameterized::DefinitionImpl*)(mParameterizedTraits->alloc(allocSize));
	memset(static_cast<void*>(ParamDefTable), 0, allocSize);

	for (physx::PxU32 i = 0; i < NumParamDefs; ++i)
	{
		NX_PARAM_PLACEMENT_NEW(ParamDefTable + i, NxParameterized::DefinitionImpl)(*mParameterizedTraits);
	}

	// Initialize DefinitionImpl node: nodeIndex=0, longName=""
	{
		NxParameterized::DefinitionImpl* ParamDef = &ParamDefTable[0];
		ParamDef->init("", TYPE_STRUCT, "STRUCT", true);

#ifdef NX_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("shortDescription", "Contains the asset properties for this Turbulence field sampler.", true);
		ParamDefTable[0].setHints((const NxParameterized::Hint**)HintPtrTable, 1);

#endif /* NX_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=1, longName="gridXRange"
	{
		NxParameterized::DefinitionImpl* ParamDef = &ParamDefTable[1];
		ParamDef->init("gridXRange", TYPE_STRUCT, "turbulenceRangeStructEnum", true);

#ifdef NX_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("shortDescription", "Number of grid cells in X dimension.", true);
		ParamDefTable[1].setHints((const NxParameterized::Hint**)HintPtrTable, 1);

#endif /* NX_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=2, longName="gridXRange.min"
	{
		NxParameterized::DefinitionImpl* ParamDef = &ParamDefTable[2];
		ParamDef->init("min", TYPE_ENUM, NULL, true);

#ifdef NX_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("shortDescription", "Turbulence resolution. The higher resolution, the higher precision, but the simulation time is also longer. This is the lower bound of possible turbulence grid resolution, depending on the LOD settings", true);
		ParamDefTable[2].setHints((const NxParameterized::Hint**)HintPtrTable, 1);

#endif /* NX_PARAMETERIZED_HIDE_DESCRIPTIONS */

		static const char* const EnumVals[] = { "EGR_12", "EGR_16", "EGR_24", "EGR_32", "EGR_48", "EGR_64", "EGR_96", "EGR_128" };
		ParamDefTable[2].setEnumVals((const char**)EnumVals, 8);




	}

	// Initialize DefinitionImpl node: nodeIndex=3, longName="gridXRange.max"
	{
		NxParameterized::DefinitionImpl* ParamDef = &ParamDefTable[3];
		ParamDef->init("max", TYPE_ENUM, NULL, true);

#ifdef NX_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("shortDescription", "Turbulence resolution. The higher resolution, the higher precision, but the simulation time is also longer. This is the higher bound of possible turbulence grid resolution, depending on the LOD settings", true);
		ParamDefTable[3].setHints((const NxParameterized::Hint**)HintPtrTable, 1);

#endif /* NX_PARAMETERIZED_HIDE_DESCRIPTIONS */

		static const char* const EnumVals[] = { "EGR_12", "EGR_16", "EGR_24", "EGR_32", "EGR_48", "EGR_64", "EGR_96", "EGR_128" };
		ParamDefTable[3].setEnumVals((const char**)EnumVals, 8);




	}

	// Initialize DefinitionImpl node: nodeIndex=4, longName="gridYRange"
	{
		NxParameterized::DefinitionImpl* ParamDef = &ParamDefTable[4];
		ParamDef->init("gridYRange", TYPE_STRUCT, "turbulenceRangeStructEnum", true);

#ifdef NX_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("shortDescription", "Number of grid cells in Y dimension.", true);
		ParamDefTable[4].setHints((const NxParameterized::Hint**)HintPtrTable, 1);

#endif /* NX_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=5, longName="gridYRange.min"
	{
		NxParameterized::DefinitionImpl* ParamDef = &ParamDefTable[5];
		ParamDef->init("min", TYPE_ENUM, NULL, true);

#ifdef NX_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("shortDescription", "Turbulence resolution. The higher resolution, the higher precision, but the simulation time is also longer. This is the lower bound of possible turbulence grid resolution, depending on the LOD settings", true);
		ParamDefTable[5].setHints((const NxParameterized::Hint**)HintPtrTable, 1);

#endif /* NX_PARAMETERIZED_HIDE_DESCRIPTIONS */

		static const char* const EnumVals[] = { "EGR_12", "EGR_16", "EGR_24", "EGR_32", "EGR_48", "EGR_64", "EGR_96", "EGR_128" };
		ParamDefTable[5].setEnumVals((const char**)EnumVals, 8);




	}

	// Initialize DefinitionImpl node: nodeIndex=6, longName="gridYRange.max"
	{
		NxParameterized::DefinitionImpl* ParamDef = &ParamDefTable[6];
		ParamDef->init("max", TYPE_ENUM, NULL, true);

#ifdef NX_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("shortDescription", "Turbulence resolution. The higher resolution, the higher precision, but the simulation time is also longer. This is the higher bound of possible turbulence grid resolution, depending on the LOD settings", true);
		ParamDefTable[6].setHints((const NxParameterized::Hint**)HintPtrTable, 1);

#endif /* NX_PARAMETERIZED_HIDE_DESCRIPTIONS */

		static const char* const EnumVals[] = { "EGR_12", "EGR_16", "EGR_24", "EGR_32", "EGR_48", "EGR_64", "EGR_96", "EGR_128" };
		ParamDefTable[6].setEnumVals((const char**)EnumVals, 8);




	}

	// Initialize DefinitionImpl node: nodeIndex=7, longName="gridZRange"
	{
		NxParameterized::DefinitionImpl* ParamDef = &ParamDefTable[7];
		ParamDef->init("gridZRange", TYPE_STRUCT, "turbulenceRangeStructEnum", true);

#ifdef NX_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("shortDescription", "Number of grid cells in Z dimension.", true);
		ParamDefTable[7].setHints((const NxParameterized::Hint**)HintPtrTable, 1);

#endif /* NX_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=8, longName="gridZRange.min"
	{
		NxParameterized::DefinitionImpl* ParamDef = &ParamDefTable[8];
		ParamDef->init("min", TYPE_ENUM, NULL, true);

#ifdef NX_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("shortDescription", "Turbulence resolution. The higher resolution, the higher precision, but the simulation time is also longer. This is the lower bound of possible turbulence grid resolution, depending on the LOD settings", true);
		ParamDefTable[8].setHints((const NxParameterized::Hint**)HintPtrTable, 1);

#endif /* NX_PARAMETERIZED_HIDE_DESCRIPTIONS */

		static const char* const EnumVals[] = { "EGR_12", "EGR_16", "EGR_24", "EGR_32", "EGR_48", "EGR_64", "EGR_96", "EGR_128" };
		ParamDefTable[8].setEnumVals((const char**)EnumVals, 8);




	}

	// Initialize DefinitionImpl node: nodeIndex=9, longName="gridZRange.max"
	{
		NxParameterized::DefinitionImpl* ParamDef = &ParamDefTable[9];
		ParamDef->init("max", TYPE_ENUM, NULL, true);

#ifdef NX_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("shortDescription", "Turbulence resolution. The higher resolution, the higher precision, but the simulation time is also longer. This is the higher bound of possible turbulence grid resolution, depending on the LOD settings", true);
		ParamDefTable[9].setHints((const NxParameterized::Hint**)HintPtrTable, 1);

#endif /* NX_PARAMETERIZED_HIDE_DESCRIPTIONS */

		static const char* const EnumVals[] = { "EGR_12", "EGR_16", "EGR_24", "EGR_32", "EGR_48", "EGR_64", "EGR_96", "EGR_128" };
		ParamDefTable[9].setEnumVals((const char**)EnumVals, 8);




	}

	// Initialize DefinitionImpl node: nodeIndex=10, longName="gridSizeWorld"
	{
		NxParameterized::DefinitionImpl* ParamDef = &ParamDefTable[10];
		ParamDef->init("gridSizeWorld", TYPE_VEC3, NULL, true);

#ifdef NX_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("shortDescription", "Size of the grid in world space.", true);
		ParamDefTable[10].setHints((const NxParameterized::Hint**)HintPtrTable, 1);

#endif /* NX_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=11, longName="updatesPerFrameRange"
	{
		NxParameterized::DefinitionImpl* ParamDef = &ParamDefTable[11];
		ParamDef->init("updatesPerFrameRange", TYPE_STRUCT, "rangeStructF32", true);

#ifdef NX_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("shortDescription", "The number of updates per frame. See APEX documentation for limitations.", true);
		ParamDefTable[11].setHints((const NxParameterized::Hint**)HintPtrTable, 1);

#endif /* NX_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=12, longName="updatesPerFrameRange.min"
	{
		NxParameterized::DefinitionImpl* ParamDef = &ParamDefTable[12];
		ParamDef->init("min", TYPE_F32, NULL, true);

#ifdef NX_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("shortDescription", "Minimum value", true);
		ParamDefTable[12].setHints((const NxParameterized::Hint**)HintPtrTable, 1);

#endif /* NX_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=13, longName="updatesPerFrameRange.max"
	{
		NxParameterized::DefinitionImpl* ParamDef = &ParamDefTable[13];
		ParamDef->init("max", TYPE_F32, NULL, true);

#ifdef NX_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("shortDescription", "Maximum value", true);
		ParamDefTable[13].setHints((const NxParameterized::Hint**)HintPtrTable, 1);

#endif /* NX_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=14, longName="angularVelocityMultiplier"
	{
		NxParameterized::DefinitionImpl* ParamDef = &ParamDefTable[14];
		ParamDef->init("angularVelocityMultiplier", TYPE_F32, NULL, true);

#ifdef NX_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("shortDescription", "a multiplier for the angular velocity set by the user.", true);
		ParamDefTable[14].setHints((const NxParameterized::Hint**)HintPtrTable, 1);

#endif /* NX_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=15, longName="angularVelocityClamp"
	{
		NxParameterized::DefinitionImpl* ParamDef = &ParamDefTable[15];
		ParamDef->init("angularVelocityClamp", TYPE_F32, NULL, true);

#ifdef NX_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("shortDescription", "a clamp for the angular velocity set by the user.", true);
		ParamDefTable[15].setHints((const NxParameterized::Hint**)HintPtrTable, 1);

#endif /* NX_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=16, longName="linearVelocityMultiplier"
	{
		NxParameterized::DefinitionImpl* ParamDef = &ParamDefTable[16];
		ParamDef->init("linearVelocityMultiplier", TYPE_F32, NULL, true);

#ifdef NX_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("shortDescription", "a multiplier for the linear velocity set by the user.", true);
		ParamDefTable[16].setHints((const NxParameterized::Hint**)HintPtrTable, 1);

#endif /* NX_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=17, longName="linearVelocityClamp"
	{
		NxParameterized::DefinitionImpl* ParamDef = &ParamDefTable[17];
		ParamDef->init("linearVelocityClamp", TYPE_F32, NULL, true);

#ifdef NX_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("shortDescription", "a clamp for the linear velocity set by the user.", true);
		ParamDefTable[17].setHints((const NxParameterized::Hint**)HintPtrTable, 1);

#endif /* NX_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=18, longName="velocityFieldFadeTime"
	{
		NxParameterized::DefinitionImpl* ParamDef = &ParamDefTable[18];
		ParamDef->init("velocityFieldFadeTime", TYPE_F32, NULL, true);

#ifdef NX_PARAMETERIZED_HIDE_DESCRIPTIONS

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("max", physx::PxU64(1000), true);
		HintTable[1].init("min", physx::PxU64(0), true);
		ParamDefTable[18].setHints((const NxParameterized::Hint**)HintPtrTable, 2);

#else

		static HintImpl HintTable[3];
		static Hint* HintPtrTable[3] = { &HintTable[0], &HintTable[1], &HintTable[2], };
		HintTable[0].init("max", physx::PxU64(1000), true);
		HintTable[1].init("min", physx::PxU64(0), true);
		HintTable[2].init("shortDescription", "Time of velocity field cleaning process [sec]. Cleaning disabled by default.", true);
		ParamDefTable[18].setHints((const NxParameterized::Hint**)HintPtrTable, 3);

#endif /* NX_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=19, longName="velocityFieldFadeDelay"
	{
		NxParameterized::DefinitionImpl* ParamDef = &ParamDefTable[19];
		ParamDef->init("velocityFieldFadeDelay", TYPE_F32, NULL, true);

#ifdef NX_PARAMETERIZED_HIDE_DESCRIPTIONS

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("max", physx::PxU64(1000), true);
		HintTable[1].init("min", physx::PxU64(0), true);
		ParamDefTable[19].setHints((const NxParameterized::Hint**)HintPtrTable, 2);

#else

		static HintImpl HintTable[3];
		static Hint* HintPtrTable[3] = { &HintTable[0], &HintTable[1], &HintTable[2], };
		HintTable[0].init("max", physx::PxU64(1000), true);
		HintTable[1].init("min", physx::PxU64(0), true);
		HintTable[2].init("shortDescription", "Time without activity before velocity field cleaning process starts [sec]. ", true);
		ParamDefTable[19].setHints((const NxParameterized::Hint**)HintPtrTable, 3);

#endif /* NX_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=20, longName="velocityFieldFadeIntensity"
	{
		NxParameterized::DefinitionImpl* ParamDef = &ParamDefTable[20];
		ParamDef->init("velocityFieldFadeIntensity", TYPE_F32, NULL, true);

#ifdef NX_PARAMETERIZED_HIDE_DESCRIPTIONS

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("max", physx::PxU64(1), true);
		HintTable[1].init("min", physx::PxF64(0.01), true);
		ParamDefTable[20].setHints((const NxParameterized::Hint**)HintPtrTable, 2);

#else

		static HintImpl HintTable[3];
		static Hint* HintPtrTable[3] = { &HintTable[0], &HintTable[1], &HintTable[2], };
		HintTable[0].init("max", physx::PxU64(1), true);
		HintTable[1].init("min", physx::PxF64(0.01), true);
		HintTable[2].init("shortDescription", "This parameter sets how much each velocity vector should be damped, so (1 - velocityFieldFadeIntensity) of original velocity vector magnitude will be left after the fade process finishes.", true);
		ParamDefTable[20].setHints((const NxParameterized::Hint**)HintPtrTable, 3);

#endif /* NX_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=21, longName="boundaryFadePercentage"
	{
		NxParameterized::DefinitionImpl* ParamDef = &ParamDefTable[21];
		ParamDef->init("boundaryFadePercentage", TYPE_F32, NULL, true);

#ifdef NX_PARAMETERIZED_HIDE_DESCRIPTIONS

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("max", physx::PxU64(1), true);
		HintTable[1].init("min", physx::PxU64(0), true);
		ParamDefTable[21].setHints((const NxParameterized::Hint**)HintPtrTable, 2);

#else

		static HintImpl HintTable[3];
		static Hint* HintPtrTable[3] = { &HintTable[0], &HintTable[1], &HintTable[2], };
		HintTable[0].init("max", physx::PxU64(1), true);
		HintTable[1].init("min", physx::PxU64(0), true);
		HintTable[2].init("shortDescription", "Percentage of distance from boundary to center where fade out starts.", true);
		ParamDefTable[21].setHints((const NxParameterized::Hint**)HintPtrTable, 3);

#endif /* NX_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=22, longName="boundarySizePercentage"
	{
		NxParameterized::DefinitionImpl* ParamDef = &ParamDefTable[22];
		ParamDef->init("boundarySizePercentage", TYPE_F32, NULL, true);

#ifdef NX_PARAMETERIZED_HIDE_DESCRIPTIONS

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("max", physx::PxU64(1), true);
		HintTable[1].init("min", physx::PxU64(0), true);
		ParamDefTable[22].setHints((const NxParameterized::Hint**)HintPtrTable, 2);

#else

		static HintImpl HintTable[3];
		static Hint* HintPtrTable[3] = { &HintTable[0], &HintTable[1], &HintTable[2], };
		HintTable[0].init("max", physx::PxU64(1), true);
		HintTable[1].init("min", physx::PxU64(0), true);
		HintTable[2].init("shortDescription", "Boundary size as the percentage of grid size.", true);
		ParamDefTable[22].setHints((const NxParameterized::Hint**)HintPtrTable, 3);

#endif /* NX_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=23, longName="collisionFilterDataName"
	{
		NxParameterized::DefinitionImpl* ParamDef = &ParamDefTable[23];
		ParamDef->init("collisionFilterDataName", TYPE_STRING, NULL, true);

#ifdef NX_PARAMETERIZED_HIDE_DESCRIPTIONS

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("HIDDEN", physx::PxU64(1), true);
		ParamDefTable[23].setHints((const NxParameterized::Hint**)HintPtrTable, 1);

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("HIDDEN", physx::PxU64(1), true);
		HintTable[1].init("shortDescription", "The filter data (group/groupsMask) name for TurbulenceFS vs PhysX interaction.", true);
		ParamDefTable[23].setHints((const NxParameterized::Hint**)HintPtrTable, 2);

#endif /* NX_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=24, longName="fieldBoundaryFilterDataName"
	{
		NxParameterized::DefinitionImpl* ParamDef = &ParamDefTable[24];
		ParamDef->init("fieldBoundaryFilterDataName", TYPE_STRING, NULL, true);

#ifdef NX_PARAMETERIZED_HIDE_DESCRIPTIONS

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("HIDDEN", physx::PxU64(1), true);
		ParamDefTable[24].setHints((const NxParameterized::Hint**)HintPtrTable, 1);

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("HIDDEN", physx::PxU64(1), true);
		HintTable[1].init("shortDescription", "The filter data name for TurbulenceFS vs Field Boundaries interaction.", true);
		ParamDefTable[24].setHints((const NxParameterized::Hint**)HintPtrTable, 2);

#endif /* NX_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=25, longName="fieldSamplerFilterDataName"
	{
		NxParameterized::DefinitionImpl* ParamDef = &ParamDefTable[25];
		ParamDef->init("fieldSamplerFilterDataName", TYPE_STRING, NULL, true);

#ifdef NX_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("shortDescription", "The filter data name for TurbulenceFS vs other Field Samplers interaction.", true);
		ParamDefTable[25].setHints((const NxParameterized::Hint**)HintPtrTable, 1);

#endif /* NX_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=26, longName="maxCollidingObjects"
	{
		NxParameterized::DefinitionImpl* ParamDef = &ParamDefTable[26];
		ParamDef->init("maxCollidingObjects", TYPE_U32, NULL, true);

#ifdef NX_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("shortDescription", "The maximum number of colliding objects.", true);
		ParamDefTable[26].setHints((const NxParameterized::Hint**)HintPtrTable, 1);

#endif /* NX_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=27, longName="maxVelocitySources"
	{
		NxParameterized::DefinitionImpl* ParamDef = &ParamDefTable[27];
		ParamDef->init("maxVelocitySources", TYPE_U32, NULL, true);

#ifdef NX_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("shortDescription", "The maximum number of velocity source.", true);
		ParamDefTable[27].setHints((const NxParameterized::Hint**)HintPtrTable, 1);

#endif /* NX_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=28, longName="maxHeatSources"
	{
		NxParameterized::DefinitionImpl* ParamDef = &ParamDefTable[28];
		ParamDef->init("maxHeatSources", TYPE_U32, NULL, true);

#ifdef NX_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("shortDescription", "The maximum number of heat source.", true);
		ParamDefTable[28].setHints((const NxParameterized::Hint**)HintPtrTable, 1);

#endif /* NX_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=29, longName="maxSubstanceSources"
	{
		NxParameterized::DefinitionImpl* ParamDef = &ParamDefTable[29];
		ParamDef->init("maxSubstanceSources", TYPE_U32, NULL, true);

#ifdef NX_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("shortDescription", "The maximum number of substance source (computed if density enabled).", true);
		ParamDefTable[29].setHints((const NxParameterized::Hint**)HintPtrTable, 1);

#endif /* NX_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=30, longName="dragCoeff"
	{
		NxParameterized::DefinitionImpl* ParamDef = &ParamDefTable[30];
		ParamDef->init("dragCoeff", TYPE_F32, NULL, true);

#ifdef NX_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("shortDescription", "Coefficient for deriving drag force from velocity (if equals to zero, direct grid velocity is used).", true);
		ParamDefTable[30].setHints((const NxParameterized::Hint**)HintPtrTable, 1);

#endif /* NX_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=31, longName="externalVelocity"
	{
		NxParameterized::DefinitionImpl* ParamDef = &ParamDefTable[31];
		ParamDef->init("externalVelocity", TYPE_VEC3, NULL, true);

#ifdef NX_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("shortDescription", "Adds a single directional velocity to the grid.", true);
		ParamDefTable[31].setHints((const NxParameterized::Hint**)HintPtrTable, 1);

#endif /* NX_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=32, longName="fieldVelocityMultiplier"
	{
		NxParameterized::DefinitionImpl* ParamDef = &ParamDefTable[32];
		ParamDef->init("fieldVelocityMultiplier", TYPE_F32, NULL, true);

#ifdef NX_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("shortDescription", "A multiplier for the field velocity.", true);
		ParamDefTable[32].setHints((const NxParameterized::Hint**)HintPtrTable, 1);

#endif /* NX_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=33, longName="fieldVelocityWeight"
	{
		NxParameterized::DefinitionImpl* ParamDef = &ParamDefTable[33];
		ParamDef->init("fieldVelocityWeight", TYPE_F32, NULL, true);

#ifdef NX_PARAMETERIZED_HIDE_DESCRIPTIONS

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("max", physx::PxU64(1), true);
		HintTable[1].init("min", physx::PxU64(0), true);
		ParamDefTable[33].setHints((const NxParameterized::Hint**)HintPtrTable, 2);

#else

		static HintImpl HintTable[3];
		static Hint* HintPtrTable[3] = { &HintTable[0], &HintTable[1], &HintTable[2], };
		HintTable[0].init("max", physx::PxU64(1), true);
		HintTable[1].init("min", physx::PxU64(0), true);
		HintTable[2].init("shortDescription", "The effect of the field velocity on objects. A value of 1 causes objects to only be affected by the grid, a value of 0 allows objects to be controlled by other field samplers.", true);
		ParamDefTable[33].setHints((const NxParameterized::Hint**)HintPtrTable, 3);

#endif /* NX_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=34, longName="useHeat"
	{
		NxParameterized::DefinitionImpl* ParamDef = &ParamDefTable[34];
		ParamDef->init("useHeat", TYPE_BOOL, NULL, true);

#ifdef NX_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("shortDescription", "Enable whether or not to use heat in the simulation.", true);
		ParamDefTable[34].setHints((const NxParameterized::Hint**)HintPtrTable, 1);

#endif /* NX_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=35, longName="heatParams"
	{
		NxParameterized::DefinitionImpl* ParamDef = &ParamDefTable[35];
		ParamDef->init("heatParams", TYPE_STRUCT, "HeatParams", true);






	}

	// Initialize DefinitionImpl node: nodeIndex=36, longName="heatParams.temperatureBasedForceMultiplier"
	{
		NxParameterized::DefinitionImpl* ParamDef = &ParamDefTable[36];
		ParamDef->init("temperatureBasedForceMultiplier", TYPE_F32, NULL, true);

#ifdef NX_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("shortDescription", "Multiplier for force induced by heat source.", true);
		ParamDefTable[36].setHints((const NxParameterized::Hint**)HintPtrTable, 1);

#endif /* NX_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=37, longName="heatParams.ambientTemperature"
	{
		NxParameterized::DefinitionImpl* ParamDef = &ParamDefTable[37];
		ParamDef->init("ambientTemperature", TYPE_F32, NULL, true);

#ifdef NX_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("shortDescription", "Environment temperature.", true);
		ParamDefTable[37].setHints((const NxParameterized::Hint**)HintPtrTable, 1);

#endif /* NX_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=38, longName="heatParams.heatForceDirection"
	{
		NxParameterized::DefinitionImpl* ParamDef = &ParamDefTable[38];
		ParamDef->init("heatForceDirection", TYPE_VEC3, NULL, true);

#ifdef NX_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("shortDescription", "Direction of the force induced by heat source.", true);
		ParamDefTable[38].setHints((const NxParameterized::Hint**)HintPtrTable, 1);

#endif /* NX_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=39, longName="heatParams.thermalConductivity"
	{
		NxParameterized::DefinitionImpl* ParamDef = &ParamDefTable[39];
		ParamDef->init("thermalConductivity", TYPE_F32, NULL, true);

#ifdef NX_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("shortDescription", "Thermal conductivity. Default value is set for air.", true);
		ParamDefTable[39].setHints((const NxParameterized::Hint**)HintPtrTable, 1);

#endif /* NX_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=40, longName="useDensity"
	{
		NxParameterized::DefinitionImpl* ParamDef = &ParamDefTable[40];
		ParamDef->init("useDensity", TYPE_BOOL, NULL, true);

#ifdef NX_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("shortDescription", "Enable whether or not to use density in the simulation.", true);
		ParamDefTable[40].setHints((const NxParameterized::Hint**)HintPtrTable, 1);

#endif /* NX_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=41, longName="densityParams"
	{
		NxParameterized::DefinitionImpl* ParamDef = &ParamDefTable[41];
		ParamDef->init("densityParams", TYPE_STRUCT, "DensityParams", true);






	}

	// Initialize DefinitionImpl node: nodeIndex=42, longName="densityParams.diffusionCoef"
	{
		NxParameterized::DefinitionImpl* ParamDef = &ParamDefTable[42];
		ParamDef->init("diffusionCoef", TYPE_F32, NULL, true);

#ifdef NX_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("shortDescription", "Diffusion coefficient for density (analog for viscosity in velocity equation.", true);
		ParamDefTable[42].setHints((const NxParameterized::Hint**)HintPtrTable, 1);

#endif /* NX_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=43, longName="densityParams.densityFieldFade"
	{
		NxParameterized::DefinitionImpl* ParamDef = &ParamDefTable[43];
		ParamDef->init("densityFieldFade", TYPE_F32, NULL, true);

#ifdef NX_PARAMETERIZED_HIDE_DESCRIPTIONS

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("max", physx::PxU64(1), true);
		HintTable[1].init("min", physx::PxU64(0), true);
		ParamDefTable[43].setHints((const NxParameterized::Hint**)HintPtrTable, 2);

#else

		static HintImpl HintTable[3];
		static Hint* HintPtrTable[3] = { &HintTable[0], &HintTable[1], &HintTable[2], };
		HintTable[0].init("max", physx::PxU64(1), true);
		HintTable[1].init("min", physx::PxU64(0), true);
		HintTable[2].init("shortDescription", "Each cell in density field are multiplied by (1 - densityFieldFade) every frame.", true);
		ParamDefTable[43].setHints((const NxParameterized::Hint**)HintPtrTable, 3);

#endif /* NX_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=44, longName="densityParams.densityGridMultiplier"
	{
		NxParameterized::DefinitionImpl* ParamDef = &ParamDefTable[44];
		ParamDef->init("densityGridMultiplier", TYPE_U32, NULL, true);

#ifdef NX_PARAMETERIZED_HIDE_DESCRIPTIONS

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("min", physx::PxU64(1), true);
		ParamDefTable[44].setHints((const NxParameterized::Hint**)HintPtrTable, 1);

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("min", physx::PxU64(1), true);
		HintTable[1].init("shortDescription", "Density grid resolution multiplier.", true);
		ParamDefTable[44].setHints((const NxParameterized::Hint**)HintPtrTable, 2);

#endif /* NX_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=45, longName="isEnabledOptimizedLOD"
	{
		NxParameterized::DefinitionImpl* ParamDef = &ParamDefTable[45];
		ParamDef->init("isEnabledOptimizedLOD", TYPE_BOOL, NULL, true);

#ifdef NX_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("shortDescription", "Enable more aggressive LOD.", true);
		ParamDefTable[45].setHints((const NxParameterized::Hint**)HintPtrTable, 1);

#endif /* NX_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=46, longName="customLOD"
	{
		NxParameterized::DefinitionImpl* ParamDef = &ParamDefTable[46];
		ParamDef->init("customLOD", TYPE_F32, NULL, true);

#ifdef NX_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("shortDescription", "Force the current LOD to a particular value, range is 0-1:	1.0f is maximum, 0.0f is minimum simulation quality.", true);
		ParamDefTable[46].setHints((const NxParameterized::Hint**)HintPtrTable, 1);

#endif /* NX_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=47, longName="lodWeights"
	{
		NxParameterized::DefinitionImpl* ParamDef = &ParamDefTable[47];
		ParamDef->init("lodWeights", TYPE_STRUCT, "LODWeights", true);






	}

	// Initialize DefinitionImpl node: nodeIndex=48, longName="lodWeights.maxDistance"
	{
		NxParameterized::DefinitionImpl* ParamDef = &ParamDefTable[48];
		ParamDef->init("maxDistance", TYPE_F32, NULL, true);

#ifdef NX_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("shortDescription", "Objects greater than this distance from the player will be culled more aggressively", true);
		ParamDefTable[48].setHints((const NxParameterized::Hint**)HintPtrTable, 1);

#endif /* NX_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=49, longName="lodWeights.distanceWeight"
	{
		NxParameterized::DefinitionImpl* ParamDef = &ParamDefTable[49];
		ParamDef->init("distanceWeight", TYPE_F32, NULL, true);

#ifdef NX_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("shortDescription", "Weight given to distance parameter in LOD function", true);
		ParamDefTable[49].setHints((const NxParameterized::Hint**)HintPtrTable, 1);

#endif /* NX_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=50, longName="lodWeights.bias"
	{
		NxParameterized::DefinitionImpl* ParamDef = &ParamDefTable[50];
		ParamDef->init("bias", TYPE_F32, NULL, true);

#ifdef NX_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("shortDescription", "benefit = ((distanceWeight * distanceFactor + bias) * SimulationCost + benefitBias) * benefitWeight", true);
		ParamDefTable[50].setHints((const NxParameterized::Hint**)HintPtrTable, 1);

#endif /* NX_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=51, longName="lodWeights.benefitBias"
	{
		NxParameterized::DefinitionImpl* ParamDef = &ParamDefTable[51];
		ParamDef->init("benefitBias", TYPE_F32, NULL, true);

#ifdef NX_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("shortDescription", "benefit = ((distanceWeight * distanceFactor + bias) * SimulationCost + benefitBias) * benefitWeight", true);
		ParamDefTable[51].setHints((const NxParameterized::Hint**)HintPtrTable, 1);

#endif /* NX_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=52, longName="lodWeights.benefitWeight"
	{
		NxParameterized::DefinitionImpl* ParamDef = &ParamDefTable[52];
		ParamDef->init("benefitWeight", TYPE_F32, NULL, true);

#ifdef NX_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("shortDescription", "benefit = ((distanceWeight * distanceFactor + bias) * SimulationCost + benefitBias) * benefitWeight", true);
		ParamDefTable[52].setHints((const NxParameterized::Hint**)HintPtrTable, 1);

#endif /* NX_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=53, longName="noiseParams"
	{
		NxParameterized::DefinitionImpl* ParamDef = &ParamDefTable[53];
		ParamDef->init("noiseParams", TYPE_STRUCT, "NoiseParams", true);






	}

	// Initialize DefinitionImpl node: nodeIndex=54, longName="noiseParams.noiseStrength"
	{
		NxParameterized::DefinitionImpl* ParamDef = &ParamDefTable[54];
		ParamDef->init("noiseStrength", TYPE_F32, NULL, true);

#ifdef NX_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("shortDescription", "The strength of the noise added to the simulation.", true);
		ParamDefTable[54].setHints((const NxParameterized::Hint**)HintPtrTable, 1);

#endif /* NX_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=55, longName="noiseParams.noiseSpacePeriod"
	{
		NxParameterized::DefinitionImpl* ParamDef = &ParamDefTable[55];
		ParamDef->init("noiseSpacePeriod", TYPE_VEC3, NULL, true);

#ifdef NX_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("shortDescription", "Noise period in space.", true);
		ParamDefTable[55].setHints((const NxParameterized::Hint**)HintPtrTable, 1);

#endif /* NX_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=56, longName="noiseParams.noiseTimePeriod"
	{
		NxParameterized::DefinitionImpl* ParamDef = &ParamDefTable[56];
		ParamDef->init("noiseTimePeriod", TYPE_F32, NULL, true);

#ifdef NX_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("shortDescription", "Noise time period.", true);
		ParamDefTable[56].setHints((const NxParameterized::Hint**)HintPtrTable, 1);

#endif /* NX_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=57, longName="noiseParams.noiseOctaves"
	{
		NxParameterized::DefinitionImpl* ParamDef = &ParamDefTable[57];
		ParamDef->init("noiseOctaves", TYPE_U32, NULL, true);

#ifdef NX_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("shortDescription", "Number of the noise octaves (more octaves give more turbulent noise, but increase computational time).", true);
		ParamDefTable[57].setHints((const NxParameterized::Hint**)HintPtrTable, 1);

#endif /* NX_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=58, longName="dragCoeffForRigidBody"
	{
		NxParameterized::DefinitionImpl* ParamDef = &ParamDefTable[58];
		ParamDef->init("dragCoeffForRigidBody", TYPE_F32, NULL, true);

#ifdef NX_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("shortDescription", "It is not true drag coef just mixing coefficient for slip and no-slip boundary condition. If set to zero supposed slip boundary condition on rigid bodies. If set to 1 supposed no-slip boundary condition else mixed (partly slip)", true);
		ParamDefTable[58].setHints((const NxParameterized::Hint**)HintPtrTable, 1);

#endif /* NX_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=59, longName="fluidViscosity"
	{
		NxParameterized::DefinitionImpl* ParamDef = &ParamDefTable[59];
		ParamDef->init("fluidViscosity", TYPE_F32, NULL, true);

#ifdef NX_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("shortDescription", "Viscosity is the coefficient for velocity diffusion. If 0. there is no diffusion.", true);
		ParamDefTable[59].setHints((const NxParameterized::Hint**)HintPtrTable, 1);

#endif /* NX_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=60, longName="volumeRenderMaterialName"
	{
		NxParameterized::DefinitionImpl* ParamDef = &ParamDefTable[60];
		ParamDef->init("volumeRenderMaterialName", TYPE_REF, NULL, true);

#ifdef NX_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("shortDescription", "The optional volume render material name", true);
		ParamDefTable[60].setHints((const NxParameterized::Hint**)HintPtrTable, 1);

#endif /* NX_PARAMETERIZED_HIDE_DESCRIPTIONS */


		static const char* const RefVariantVals[] = { "ApexVolumeRenderMaterials" };
		ParamDefTable[60].setRefVariantVals((const char**)RefVariantVals, 1);



	}

	// Initialize DefinitionImpl node: nodeIndex=61, longName="useFlame"
	{
		NxParameterized::DefinitionImpl* ParamDef = &ParamDefTable[61];
		ParamDef->init("useFlame", TYPE_BOOL, NULL, true);

#ifdef NX_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("shortDescription", "Enable whether or not to use flame in the simulation.", true);
		ParamDefTable[61].setHints((const NxParameterized::Hint**)HintPtrTable, 1);

#endif /* NX_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=62, longName="flameParams"
	{
		NxParameterized::DefinitionImpl* ParamDef = &ParamDefTable[62];
		ParamDef->init("flameParams", TYPE_STRUCT, "FlameParams", true);






	}

	// Initialize DefinitionImpl node: nodeIndex=63, longName="flameParams.IgnitionTemp"
	{
		NxParameterized::DefinitionImpl* ParamDef = &ParamDefTable[63];
		ParamDef->init("IgnitionTemp", TYPE_F32, NULL, true);

#ifdef NX_PARAMETERIZED_HIDE_DESCRIPTIONS

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("tweakable", physx::PxU64(1), true);
		ParamDefTable[63].setHints((const NxParameterized::Hint**)HintPtrTable, 1);

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("shortDescription", "Temperature at which ignition occurs.", true);
		HintTable[1].init("tweakable", physx::PxU64(1), true);
		ParamDefTable[63].setHints((const NxParameterized::Hint**)HintPtrTable, 2);

#endif /* NX_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=64, longName="flameParams.MaxIgnitionTemp"
	{
		NxParameterized::DefinitionImpl* ParamDef = &ParamDefTable[64];
		ParamDef->init("MaxIgnitionTemp", TYPE_F32, NULL, true);

#ifdef NX_PARAMETERIZED_HIDE_DESCRIPTIONS

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("tweakable", physx::PxU64(1), true);
		ParamDefTable[64].setHints((const NxParameterized::Hint**)HintPtrTable, 1);

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("shortDescription", "Maximum temperature at which ignition occurs.", true);
		HintTable[1].init("tweakable", physx::PxU64(1), true);
		ParamDefTable[64].setHints((const NxParameterized::Hint**)HintPtrTable, 2);

#endif /* NX_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=65, longName="flameParams.ReactionSpeed"
	{
		NxParameterized::DefinitionImpl* ParamDef = &ParamDefTable[65];
		ParamDef->init("ReactionSpeed", TYPE_F32, NULL, true);

#ifdef NX_PARAMETERIZED_HIDE_DESCRIPTIONS

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("tweakable", physx::PxU64(1), true);
		ParamDefTable[65].setHints((const NxParameterized::Hint**)HintPtrTable, 1);

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("shortDescription", "Speed at which reaction occurs. Higher reaction speeds generate more heat and also consume fuel more quickly.", true);
		HintTable[1].init("tweakable", physx::PxU64(1), true);
		ParamDefTable[65].setHints((const NxParameterized::Hint**)HintPtrTable, 2);

#endif /* NX_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=66, longName="flameParams.HeatReleased"
	{
		NxParameterized::DefinitionImpl* ParamDef = &ParamDefTable[66];
		ParamDef->init("HeatReleased", TYPE_F32, NULL, true);

#ifdef NX_PARAMETERIZED_HIDE_DESCRIPTIONS

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("tweakable", physx::PxU64(1), true);
		ParamDefTable[66].setHints((const NxParameterized::Hint**)HintPtrTable, 1);

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("shortDescription", "Amount of temperature released during reaction.", true);
		HintTable[1].init("tweakable", physx::PxU64(1), true);
		ParamDefTable[66].setHints((const NxParameterized::Hint**)HintPtrTable, 2);

#endif /* NX_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=67, longName="flameParams.DensityEmission"
	{
		NxParameterized::DefinitionImpl* ParamDef = &ParamDefTable[67];
		ParamDef->init("DensityEmission", TYPE_F32, NULL, true);

#ifdef NX_PARAMETERIZED_HIDE_DESCRIPTIONS

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("tweakable", physx::PxU64(1), true);
		ParamDefTable[67].setHints((const NxParameterized::Hint**)HintPtrTable, 1);

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("shortDescription", "Amount of density (smoke) created during reaction", true);
		HintTable[1].init("tweakable", physx::PxU64(1), true);
		ParamDefTable[67].setHints((const NxParameterized::Hint**)HintPtrTable, 2);

#endif /* NX_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=68, longName="flameParams.FuelInefficiency"
	{
		NxParameterized::DefinitionImpl* ParamDef = &ParamDefTable[68];
		ParamDef->init("FuelInefficiency", TYPE_F32, NULL, true);

#ifdef NX_PARAMETERIZED_HIDE_DESCRIPTIONS

		static HintImpl HintTable[3];
		static Hint* HintPtrTable[3] = { &HintTable[0], &HintTable[1], &HintTable[2], };
		HintTable[0].init("max", physx::PxF64(1.0), true);
		HintTable[1].init("min", physx::PxF64(0.0), true);
		HintTable[2].init("tweakable", physx::PxU64(1), true);
		ParamDefTable[68].setHints((const NxParameterized::Hint**)HintPtrTable, 3);

#else

		static HintImpl HintTable[4];
		static Hint* HintPtrTable[4] = { &HintTable[0], &HintTable[1], &HintTable[2], &HintTable[3], };
		HintTable[0].init("max", physx::PxF64(1.0), true);
		HintTable[1].init("min", physx::PxF64(0.0), true);
		HintTable[2].init("shortDescription", " Controls how much of the burned fuel is actually not burned [0, 1]", true);
		HintTable[3].init("tweakable", physx::PxU64(1), true);
		ParamDefTable[68].setHints((const NxParameterized::Hint**)HintPtrTable, 4);

#endif /* NX_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=69, longName="flameParams.Expansion"
	{
		NxParameterized::DefinitionImpl* ParamDef = &ParamDefTable[69];
		ParamDef->init("Expansion", TYPE_F32, NULL, true);

#ifdef NX_PARAMETERIZED_HIDE_DESCRIPTIONS

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("tweakable", physx::PxU64(1), true);
		ParamDefTable[69].setHints((const NxParameterized::Hint**)HintPtrTable, 1);

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("shortDescription", "Amount of expansion generated by reaction.", true);
		HintTable[1].init("tweakable", physx::PxU64(1), true);
		ParamDefTable[69].setHints((const NxParameterized::Hint**)HintPtrTable, 2);

#endif /* NX_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=70, longName="flameParams.Cooling"
	{
		NxParameterized::DefinitionImpl* ParamDef = &ParamDefTable[70];
		ParamDef->init("Cooling", TYPE_F32, NULL, true);

#ifdef NX_PARAMETERIZED_HIDE_DESCRIPTIONS

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("tweakable", physx::PxU64(1), true);
		ParamDefTable[70].setHints((const NxParameterized::Hint**)HintPtrTable, 1);

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("shortDescription", "Exponential cooling amount", true);
		HintTable[1].init("tweakable", physx::PxU64(1), true);
		ParamDefTable[70].setHints((const NxParameterized::Hint**)HintPtrTable, 2);

#endif /* NX_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=71, longName="flameParams.Buoyancy"
	{
		NxParameterized::DefinitionImpl* ParamDef = &ParamDefTable[71];
		ParamDef->init("Buoyancy", TYPE_F32, NULL, true);

#ifdef NX_PARAMETERIZED_HIDE_DESCRIPTIONS

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("tweakable", physx::PxU64(1), true);
		ParamDefTable[71].setHints((const NxParameterized::Hint**)HintPtrTable, 1);

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("shortDescription", "Buoyancy strength. If temperature is above room temperature, upwards force is generated.", true);
		HintTable[1].init("tweakable", physx::PxU64(1), true);
		ParamDefTable[71].setHints((const NxParameterized::Hint**)HintPtrTable, 2);

#endif /* NX_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=72, longName="flameParams.BuoyancyUpVector"
	{
		NxParameterized::DefinitionImpl* ParamDef = &ParamDefTable[72];
		ParamDef->init("BuoyancyUpVector", TYPE_VEC3, NULL, true);

#ifdef NX_PARAMETERIZED_HIDE_DESCRIPTIONS

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("tweakable", physx::PxU64(1), true);
		ParamDefTable[72].setHints((const NxParameterized::Hint**)HintPtrTable, 1);

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("shortDescription", "Direction that buoyancy acts in (opposite gravity)", true);
		HintTable[1].init("tweakable", physx::PxU64(1), true);
		ParamDefTable[72].setHints((const NxParameterized::Hint**)HintPtrTable, 2);

#endif /* NX_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=73, longName="flameParams.RoomTemperature"
	{
		NxParameterized::DefinitionImpl* ParamDef = &ParamDefTable[73];
		ParamDef->init("RoomTemperature", TYPE_F32, NULL, true);

#ifdef NX_PARAMETERIZED_HIDE_DESCRIPTIONS

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("tweakable", physx::PxU64(1), true);
		ParamDefTable[73].setHints((const NxParameterized::Hint**)HintPtrTable, 1);

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("shortDescription", "Room temperature. Affects buoyancy.", true);
		HintTable[1].init("tweakable", physx::PxU64(1), true);
		ParamDefTable[73].setHints((const NxParameterized::Hint**)HintPtrTable, 2);

#endif /* NX_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=74, longName="flameParams.Dissipation"
	{
		NxParameterized::DefinitionImpl* ParamDef = &ParamDefTable[74];
		ParamDef->init("Dissipation", TYPE_VEC4, NULL, true);

#ifdef NX_PARAMETERIZED_HIDE_DESCRIPTIONS

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("tweakable", physx::PxU64(1), true);
		ParamDefTable[74].setHints((const NxParameterized::Hint**)HintPtrTable, 1);

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("shortDescription", "Amount to dissipate each channel of flame per simulation frame. This is corrected for the timestep.", true);
		HintTable[1].init("tweakable", physx::PxU64(1), true);
		ParamDefTable[74].setHints((const NxParameterized::Hint**)HintPtrTable, 2);

#endif /* NX_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=75, longName="flameParams.ResolutionMultiplier"
	{
		NxParameterized::DefinitionImpl* ParamDef = &ParamDefTable[75];
		ParamDef->init("ResolutionMultiplier", TYPE_U32, NULL, true);

#ifdef NX_PARAMETERIZED_HIDE_DESCRIPTIONS

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("max", physx::PxU64(16), true);
		HintTable[1].init("min", physx::PxU64(1), true);
		ParamDefTable[75].setHints((const NxParameterized::Hint**)HintPtrTable, 2);

#else

		static HintImpl HintTable[3];
		static Hint* HintPtrTable[3] = { &HintTable[0], &HintTable[1], &HintTable[2], };
		HintTable[0].init("max", physx::PxU64(16), true);
		HintTable[1].init("min", physx::PxU64(1), true);
		HintTable[2].init("shortDescription", "The flame resolution multiplier", true);
		ParamDefTable[75].setHints((const NxParameterized::Hint**)HintPtrTable, 3);

#endif /* NX_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=76, longName="solverAccuracy"
	{
		NxParameterized::DefinitionImpl* ParamDef = &ParamDefTable[76];
		ParamDef->init("solverAccuracy", TYPE_ENUM, NULL, true);

#ifdef NX_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("shortDescription", "Solver accuracy. Use FAST mode to improve performance, but be aware that it could lead to less accurate and stable simulation!", true);
		ParamDefTable[76].setHints((const NxParameterized::Hint**)HintPtrTable, 1);

#endif /* NX_PARAMETERIZED_HIDE_DESCRIPTIONS */

		static const char* const EnumVals[] = { "NORMAL", "FAST" };
		ParamDefTable[76].setEnumVals((const char**)EnumVals, 2);




	}

	// SetChildren for: nodeIndex=0, longName=""
	{
		static Definition* Children[39];
		Children[0] = PDEF_PTR(1);
		Children[1] = PDEF_PTR(4);
		Children[2] = PDEF_PTR(7);
		Children[3] = PDEF_PTR(10);
		Children[4] = PDEF_PTR(11);
		Children[5] = PDEF_PTR(14);
		Children[6] = PDEF_PTR(15);
		Children[7] = PDEF_PTR(16);
		Children[8] = PDEF_PTR(17);
		Children[9] = PDEF_PTR(18);
		Children[10] = PDEF_PTR(19);
		Children[11] = PDEF_PTR(20);
		Children[12] = PDEF_PTR(21);
		Children[13] = PDEF_PTR(22);
		Children[14] = PDEF_PTR(23);
		Children[15] = PDEF_PTR(24);
		Children[16] = PDEF_PTR(25);
		Children[17] = PDEF_PTR(26);
		Children[18] = PDEF_PTR(27);
		Children[19] = PDEF_PTR(28);
		Children[20] = PDEF_PTR(29);
		Children[21] = PDEF_PTR(30);
		Children[22] = PDEF_PTR(31);
		Children[23] = PDEF_PTR(32);
		Children[24] = PDEF_PTR(33);
		Children[25] = PDEF_PTR(34);
		Children[26] = PDEF_PTR(35);
		Children[27] = PDEF_PTR(40);
		Children[28] = PDEF_PTR(41);
		Children[29] = PDEF_PTR(45);
		Children[30] = PDEF_PTR(46);
		Children[31] = PDEF_PTR(47);
		Children[32] = PDEF_PTR(53);
		Children[33] = PDEF_PTR(58);
		Children[34] = PDEF_PTR(59);
		Children[35] = PDEF_PTR(60);
		Children[36] = PDEF_PTR(61);
		Children[37] = PDEF_PTR(62);
		Children[38] = PDEF_PTR(76);

		ParamDefTable[0].setChildren(Children, 39);
	}

	// SetChildren for: nodeIndex=1, longName="gridXRange"
	{
		static Definition* Children[2];
		Children[0] = PDEF_PTR(2);
		Children[1] = PDEF_PTR(3);

		ParamDefTable[1].setChildren(Children, 2);
	}

	// SetChildren for: nodeIndex=4, longName="gridYRange"
	{
		static Definition* Children[2];
		Children[0] = PDEF_PTR(5);
		Children[1] = PDEF_PTR(6);

		ParamDefTable[4].setChildren(Children, 2);
	}

	// SetChildren for: nodeIndex=7, longName="gridZRange"
	{
		static Definition* Children[2];
		Children[0] = PDEF_PTR(8);
		Children[1] = PDEF_PTR(9);

		ParamDefTable[7].setChildren(Children, 2);
	}

	// SetChildren for: nodeIndex=11, longName="updatesPerFrameRange"
	{
		static Definition* Children[2];
		Children[0] = PDEF_PTR(12);
		Children[1] = PDEF_PTR(13);

		ParamDefTable[11].setChildren(Children, 2);
	}

	// SetChildren for: nodeIndex=35, longName="heatParams"
	{
		static Definition* Children[4];
		Children[0] = PDEF_PTR(36);
		Children[1] = PDEF_PTR(37);
		Children[2] = PDEF_PTR(38);
		Children[3] = PDEF_PTR(39);

		ParamDefTable[35].setChildren(Children, 4);
	}

	// SetChildren for: nodeIndex=41, longName="densityParams"
	{
		static Definition* Children[3];
		Children[0] = PDEF_PTR(42);
		Children[1] = PDEF_PTR(43);
		Children[2] = PDEF_PTR(44);

		ParamDefTable[41].setChildren(Children, 3);
	}

	// SetChildren for: nodeIndex=47, longName="lodWeights"
	{
		static Definition* Children[5];
		Children[0] = PDEF_PTR(48);
		Children[1] = PDEF_PTR(49);
		Children[2] = PDEF_PTR(50);
		Children[3] = PDEF_PTR(51);
		Children[4] = PDEF_PTR(52);

		ParamDefTable[47].setChildren(Children, 5);
	}

	// SetChildren for: nodeIndex=53, longName="noiseParams"
	{
		static Definition* Children[4];
		Children[0] = PDEF_PTR(54);
		Children[1] = PDEF_PTR(55);
		Children[2] = PDEF_PTR(56);
		Children[3] = PDEF_PTR(57);

		ParamDefTable[53].setChildren(Children, 4);
	}

	// SetChildren for: nodeIndex=62, longName="flameParams"
	{
		static Definition* Children[13];
		Children[0] = PDEF_PTR(63);
		Children[1] = PDEF_PTR(64);
		Children[2] = PDEF_PTR(65);
		Children[3] = PDEF_PTR(66);
		Children[4] = PDEF_PTR(67);
		Children[5] = PDEF_PTR(68);
		Children[6] = PDEF_PTR(69);
		Children[7] = PDEF_PTR(70);
		Children[8] = PDEF_PTR(71);
		Children[9] = PDEF_PTR(72);
		Children[10] = PDEF_PTR(73);
		Children[11] = PDEF_PTR(74);
		Children[12] = PDEF_PTR(75);

		ParamDefTable[62].setChildren(Children, 13);
	}

	mBuiltFlag = true;

}
void TurbulenceFSAssetParams_1p4::initStrings(void)
{
	collisionFilterDataName.isAllocated = true;
	collisionFilterDataName.buf = NULL;
	fieldBoundaryFilterDataName.isAllocated = true;
	fieldBoundaryFilterDataName.buf = NULL;
	fieldSamplerFilterDataName.isAllocated = true;
	fieldSamplerFilterDataName.buf = NULL;
}

void TurbulenceFSAssetParams_1p4::initDynamicArrays(void)
{
}

void TurbulenceFSAssetParams_1p4::initDefaults(void)
{

	freeStrings();
	freeReferences();
	freeDynamicArrays();
	gridXRange.min = (const char*)"EGR_16";
	gridXRange.max = (const char*)"EGR_16";
	gridYRange.min = (const char*)"EGR_16";
	gridYRange.max = (const char*)"EGR_16";
	gridZRange.min = (const char*)"EGR_16";
	gridZRange.max = (const char*)"EGR_16";
	gridSizeWorld = physx::PxVec3(init(12, 12, 12));

	updatesPerFrameRange.min = 0.0f;
	updatesPerFrameRange.max = 1.0f;

	angularVelocityMultiplier = physx::PxF32(1);
	angularVelocityClamp = physx::PxF32(1000000);
	linearVelocityMultiplier = physx::PxF32(1);
	linearVelocityClamp = physx::PxF32(1000000);
	velocityFieldFadeTime = physx::PxF32(0);
	velocityFieldFadeDelay = physx::PxF32(2);
	velocityFieldFadeIntensity = physx::PxF32(0.995);
	boundaryFadePercentage = physx::PxF32(0.1);
	boundarySizePercentage = physx::PxF32(1);
	maxCollidingObjects = physx::PxU32(32);
	maxVelocitySources = physx::PxU32(8);
	maxHeatSources = physx::PxU32(8);
	maxSubstanceSources = physx::PxU32(8);
	dragCoeff = physx::PxF32(0);
	externalVelocity = physx::PxVec3(init(0.0, 0.0, 0.0));
	fieldVelocityMultiplier = physx::PxF32(1);
	fieldVelocityWeight = physx::PxF32(1);
	useHeat = bool(false);
	heatParams.temperatureBasedForceMultiplier = physx::PxF32(0.02);
	heatParams.ambientTemperature = physx::PxF32(0);
	heatParams.heatForceDirection = physx::PxVec3(init(0.0, 1.0, 0.0));
	heatParams.thermalConductivity = physx::PxF32(0.025);
	useDensity = bool(false);
	densityParams.diffusionCoef = physx::PxF32(0);
	densityParams.densityFieldFade = physx::PxF32(0);
	densityParams.densityGridMultiplier = physx::PxU32(1);
	isEnabledOptimizedLOD = bool(false);
	customLOD = physx::PxF32(1);
	lodWeights.maxDistance = physx::PxF32(100);
	lodWeights.distanceWeight = physx::PxF32(1);
	lodWeights.bias = physx::PxF32(0);
	lodWeights.benefitBias = physx::PxF32(0);
	lodWeights.benefitWeight = physx::PxF32(1);
	noiseParams.noiseStrength = physx::PxF32(0);
	noiseParams.noiseSpacePeriod = physx::PxVec3(init(1.0, 1.0, 1.0));
	noiseParams.noiseTimePeriod = physx::PxF32(1);
	noiseParams.noiseOctaves = physx::PxU32(1);
	dragCoeffForRigidBody = physx::PxF32(0);
	fluidViscosity = physx::PxF32(0);
	useFlame = bool(false);
	flameParams.IgnitionTemp = physx::PxF32(0.0);
	flameParams.MaxIgnitionTemp = physx::PxF32(1.0);
	flameParams.ReactionSpeed = physx::PxF32(0.2);
	flameParams.HeatReleased = physx::PxF32(0.5);
	flameParams.DensityEmission = physx::PxF32(0.0);
	flameParams.FuelInefficiency = physx::PxF32(0.0);
	flameParams.Expansion = physx::PxF32(0.5);
	flameParams.Cooling = physx::PxF32(0.0);
	flameParams.Buoyancy = physx::PxF32(0.2);
	flameParams.BuoyancyUpVector = physx::PxVec3(init(0.0,0.0,0.0));
	flameParams.RoomTemperature = physx::PxF32(0.0);
	flameParams.Dissipation = physx::PxVec4(initVec4(0.1,0.1,0.1,0.1));
	flameParams.ResolutionMultiplier = physx::PxU32(1);
	solverAccuracy = (const char*)"NORMAL";

	initDynamicArrays();
	initStrings();
	initReferences();
}

void TurbulenceFSAssetParams_1p4::initReferences(void)
{
	volumeRenderMaterialName = NULL;

}

void TurbulenceFSAssetParams_1p4::freeDynamicArrays(void)
{
}

void TurbulenceFSAssetParams_1p4::freeStrings(void)
{

	if (collisionFilterDataName.isAllocated && collisionFilterDataName.buf)
	{
		mParameterizedTraits->strfree((char*)collisionFilterDataName.buf);
	}

	if (fieldBoundaryFilterDataName.isAllocated && fieldBoundaryFilterDataName.buf)
	{
		mParameterizedTraits->strfree((char*)fieldBoundaryFilterDataName.buf);
	}

	if (fieldSamplerFilterDataName.isAllocated && fieldSamplerFilterDataName.buf)
	{
		mParameterizedTraits->strfree((char*)fieldSamplerFilterDataName.buf);
	}
}

void TurbulenceFSAssetParams_1p4::freeReferences(void)
{
	if (volumeRenderMaterialName)
	{
		volumeRenderMaterialName->destroy();
	}

}

} // namespace apex
} // namespace physx
